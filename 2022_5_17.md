[Why is reading lines from stdin much slower in C++ than Python? - Stack Overflow](https://stackoverflow.com/questions/9371238/why-is-reading-lines-from-stdin-much-slower-in-c-than-python)

I wanted to compare reading lines of string input from stdin using Python and C++ and was shocked to see my C++ code ==run an order of magnitude== slower than the equivalent Python code. Since my C++ is ==rusty== and I'm not yet an expert Pythonista, please tell me if I'm doing something wrong or if I'm misunderstanding something.

> 有道：我想比较使用Python和c++从stdin中读取字符串输入的行数，却惊讶地发现我的c++代码的运行速度比等效的Python代码慢了一个数量级。由于我的c++很生疏，而且我还不是python的专家，如果我做错了什么，或者我误解了什么，请告诉我。

我想要比较用python和C++从stdin中读取的输入的字符串行数，但是震惊的发现我C++的代码比起相同的python代码慢了一个数量级，因为我的C++是生疏的，并且我也不是一个python专家，如果我做错了或者理解错了什么东西，请告诉我。

(**TLDR answer:** include the statement: `cin.sync_with_stdio(false)` or just use `fgets` instead.

**TLDR results:** ==scroll all the way== down to the bottom of my question and look at the table.)

> (TLDR的答案:包含语句:cin.sync_with_stdio(false)或者直接使用fgets。
>
> TLDR结果:一直滚动到我的问题的底部，看看表格。)

~~这里不清楚TLDR是什么东西~~

TLDR 答案：包含声明：cin.sync_with_stdio(false)或者仅使用fgets代替

TLDR结果：一直滚动带我的问题的底部并且查看表格

**C++ code:**

```c++
#include <iostream>
#include <time.h>

using namespace std;

int main() {
    string input_line;
    long line_count = 0;
    time_t start = time(NULL);
    int sec;
    int lps;

    while (cin) {
        getline(cin, input_line);
        if (!cin.eof())
            line_count++;
    };

    sec = (int) time(NULL) - start;
    cerr << "Read " << line_count << " lines in " << sec << " seconds.";
    if (sec > 0) {
        lps = line_count / sec;
        cerr << " LPS: " << lps << endl;
    } else
        cerr << endl;
    return 0;
}

// Compiled with:
// g++ -O3 -o readline_test_cpp foo.cpp
```

**Python Equivalent:**

```py
#!/usr/bin/env python
import time
import sys

count = 0
start = time.time()

for line in  sys.stdin:
    count += 1

delta_sec = int(time.time() - start_time)
if delta_sec >= 0:
    lines_per_sec = int(round(count/delta_sec))
    print("Read {0} lines in {1} seconds. LPS: {2}".format(count, delta_sec,
       lines_per_sec))
```

**Here are my results:**

```none
$ cat test_lines | ./readline_test_cpp
Read 5570000 lines in 9 seconds. LPS: 618889

$ cat test_lines | ./readline_test.py
Read 5570000 lines in 1 seconds. LPS: 5570000
```

> 解释一下，把文件当做输入源，测试读取整个文件的行数需要多久，C++采用getline读取，python还不会，大概意思大概是这样

I should note that I tried this both under Mac OS X v10.6.8 (Snow Leopard) and Linux 2.6.32 (Red Hat Linux 6.2). The former is a MacBook Pro, and the latter is a very beefy server,==not that this is too pertinent.== 

> 我应该注意，我在Mac OS X v10.6.8(雪豹)和Linux 2.6.32 (Red Hat Linux 6.2)下都尝试了这个。前者是一台MacBook Pro，后者是一台非常强大的服务器，但这不是说得太切题了。

我注意到